<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>传送带模型：动力学与能量仿真实验室 (物理修正版)</title>
    
    <link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/KaTeX/0.16.9/katex.min.css">
    <script src="https://cdn.bootcdn.net/ajax/libs/KaTeX/0.16.9/katex.min.js"></script>
    <script src="https://cdn.bootcdn.net/ajax/libs/KaTeX/0.16.9/contrib/auto-render.min.js"></script>

    <style>
        :root { --primary: #2c3e50; --accent: #e67e22; --bg: #f8f9fa; }
        body { font-family: 'Segoe UI', Arial, sans-serif; background: var(--bg); margin: 0; padding: 20px; display: flex; flex-direction: column; align-items: center; }
        .main-layout { display: flex; gap: 20px; max-width: 1100px; width: 100%; flex-wrap: wrap; }
        .canvas-area { flex: 2; display: flex; flex-direction: column; gap: 10px; min-width: 300px; }
        
        /* 修复移动端误触和滚动冲突 */
        canvas { background: #fff; border-radius: 6px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); width: 100%; cursor: grab; touch-action: none; }
        canvas:active { cursor: grabbing; }
        
        .controls { flex: 1; background: white; padding: 20px; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); min-width: 300px; }
        .control-group { margin-bottom: 12px; display: flex; align-items: center; justify-content: space-between; }
        
        /* 修复滑块触摸问题 */
        input[type="number"], select { width: 90px; padding: 6px; border: 1px solid #ccc; border-radius: 4px; text-align: center; font-weight: bold; }
        input[type="range"] { touch-action: none; }
        
        .btn-stack { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 15px; }
        button { padding: 10px; border: none; border-radius: 4px; cursor: pointer; font-weight: bold; transition: background 0.2s; }
        .btn-apply { background: var(--primary); color: white; grid-column: span 2; margin-bottom: 5px; }
        .btn-play { background: #27ae60; color: white; }
        .btn-reset { background: #e74c3c; color: white; }
        
        .stats-grid { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px; margin-bottom: 15px; }
        .stat-card { background: #edf2f7; padding: 8px; border-radius: 4px; text-align: center; border-left: 3px solid var(--primary); }
        .stat-card small { display: block; font-size: 0.75em; color: #666; margin-bottom: 2px; }
        .stat-card span { font-family: 'Consolas', monospace; font-weight: bold; font-size: 1.1em; color: var(--primary); }
        /* 重点高亮电能 */
        .stat-card.energy-card { border-left-color: #e74c3c; background: #fdf2f2; }
        .stat-card.energy-card span { color: #c0392b; }

        .formula-display { margin-top: 20px; padding: 15px; background: #fffaf0; border: 1px dashed var(--accent); border-radius: 4px; font-size: 0.9em; }
    </style>
</head>
<body>

<h2 id="page-title">传送带模型：动力学与能量仿真 (Fix版)</h2>

<div class="main-layout">
    <div class="canvas-area">
        <div class="stats-grid">
            <div class="stat-card"><small>物块速度 $v$ (m/s)</small><span id="stat-v">0.00</span></div>
            <div class="stat-card"><small>相对位移 $\Delta s$ (m)</small><span id="stat-ds">0.00</span></div>
            <div class="stat-card"><small>摩擦生热 $Q$ (J)</small><span id="stat-q">0.00</span></div>
            <div class="stat-card"><small>重力做功 $W_G$ (J)</small><span id="stat-wg">0.00</span></div>
            <div class="stat-card"><small>动能变化 $\Delta E_k$ (J)</small><span id="stat-dek">0.00</span></div>
            <div class="stat-card energy-card"><small>电机做功 $W_{电}$ (J)</small><span id="stat-we">0.00</span></div>
        </div>
        <canvas id="simCanvas" width="700" height="350"></canvas>
        <canvas id="vtCanvas" width="700" height="220"></canvas>
    </div>

    <div class="controls">
        <h4 style="margin-top:0">参数设置</h4>
        <div class="control-group">
            <label>传送带速度 $v_b$</label>
            <input type="number" id="in-vb" value="4.0" step="0.1">
        </div>
        <div class="control-group">
            <label>物块初速 $v_0$</label>
            <input type="number" id="in-v0" value="0.0" step="0.1">
        </div>
        <div class="control-group">
            <label>倾斜方向</label>
            <select id="in-tiltDir">
                <option value="1">向右上方 (/)</option>
                <option value="-1">向右下方 (\)</option>
            </select>
        </div>
        <div class="control-group">
            <label>倾角 $\theta$ (°)</label>
            <input type="number" id="in-theta" value="30" step="1" min="0" max="80">
        </div>
        <div class="control-group">
            <label>摩擦系数 $\mu$</label>
            <input type="number" id="in-mu" value="0.50" step="0.01" min="0">
        </div>
        <div class="control-group">
            <label>质量 $m$ (kg)</label>
            <input type="number" id="in-m" value="1.0" step="0.1" min="0.1">
        </div>

        <button class="btn-apply" onclick="applyParams()">应用参数并复位</button>
        <div class="btn-stack">
            <button id="playBtn" class="btn-play" onclick="togglePlay()">开始仿真</button>
            <button class="btn-reset" onclick="hardReset()">全复位</button>
        </div>

        <div class="formula-display" id="formula-box">
            <div>能量守恒验证:</div>
            $$ W_{电} + W_G = \Delta E_k + Q $$
            $$ W_{电} = f \cdot x_{带} $$
            <div style="font-size:0.8em; color:#666; margin-top:5px">注：$W_{电}$为负时表示电机回收能量(发电)</div>
        </div>
    </div>
</div>

<script>
    const simCanvas = document.getElementById('simCanvas');
    const sCtx = simCanvas.getContext('2d');
    const vtCanvas = document.getElementById('vtCanvas');
    const vCtx = vtCanvas.getContext('2d');
    const g = 9.8;

    const ORIGIN_X = 50;  
    const ORIGIN_Y = 250; 
    const PIXELS_PER_METER = 40; 
    const BELT_LENGTH_PX = 600;

    let world = {
        running: false,
        vb: 4, v0: 0, mu: 0.5, theta: 0, m: 1, tiltDir: 1,
        initialX: 100,
        objX: 100,     
        objV: 0, relS: 0, heat: 0, accel: 0,
        // 能量统计变量
        workElec: 0, // 电机做功
        workG: 0,    // 重力做功
        startEk: 0,  // 初始动能
        
        beltOffset: 0, history: [], isDragging: false, timer: 0,
        frameCounter: 0 // 用于图表节流
    };

    function refreshMath() {
        if (typeof renderMathInElement === 'function') {
            renderMathInElement(document.getElementById('formula-box'), {
                delimiters: [ {left: '$$', right: '$$', display: true}, {left: '$', right: '$', display: false} ],
                throwOnError: false
            });
        }
    }

    function applyParams() {
        world.vb = parseFloat(document.getElementById('in-vb').value) || 0;
        world.v0 = parseFloat(document.getElementById('in-v0').value) || 0;
        world.mu = parseFloat(document.getElementById('in-mu').value) || 0;
        let angle = parseFloat(document.getElementById('in-theta').value) || 0;
        world.tiltDir = parseInt(document.getElementById('in-tiltDir').value);
        world.m = parseFloat(document.getElementById('in-m').value) || 1;
        
        world.theta = angle * (Math.PI / 180) * world.tiltDir;
        world.objX = world.initialX;
        
        resetSimData();
        // 渲染一次公式
        refreshMath();
    }

    function resetSimData() {
        world.objV = world.v0;
        world.relS = 0; world.heat = 0; world.accel = 0; world.timer = 0;
        
        // 重置能量数据
        world.workElec = 0;
        world.workG = 0;
        world.startEk = 0.5 * world.m * world.objV * world.objV;
        
        world.history = []; world.running = false;
        document.getElementById('playBtn').innerText = "开始仿真";
        calculatePhysics(0); // 预计算初始状态
        updateStats();
        drawVTChart(); // 清空图表
        render(); // 重绘场景
    }

    function hardReset() {
        world.initialX = 100; world.objX = 100;
        resetSimData();
    }

    function togglePlay() {
        if(!world.running && world.history.length === 0) {
             world.initialX = world.objX; // 记录起点
             // 重新记录初始动能，防止拖拽后改变
             world.startEk = 0.5 * world.m * world.objV * world.objV;
        }
        world.running = !world.running;
        document.getElementById('playBtn').innerText = world.running ? "暂停" : "继续";
        if(world.running) animate();
    }

    function getBeltPos(e) {
        const rect = simCanvas.getBoundingClientRect();
        const dx = (e.clientX - rect.left) - ORIGIN_X;
        const dy = (e.clientY - rect.top) - ORIGIN_Y;
        const beltX = dx * Math.cos(-world.theta) + dy * Math.sin(-world.theta);
        const beltY = -dx * Math.sin(-world.theta) + dy * Math.cos(-world.theta);
        return { x: beltX, y: beltY };
    }

    simCanvas.addEventListener('mousedown', e => {
        const pos = getBeltPos(e);
        if (Math.abs(pos.x - (world.objX - 30)) < 50 && Math.abs(pos.y + 15) < 50) {
            world.isDragging = true;
            world.running = false;
            document.getElementById('playBtn').innerText = "开始仿真";
        }
    });

    window.addEventListener('mousemove', e => {
        if (world.isDragging) {
            const pos = getBeltPos(e);
            world.objX = Math.max(50, Math.min(BELT_LENGTH_PX + 50, pos.x + 30)); 
            world.initialX = world.objX;
            resetSimData();
        }
    });

    window.addEventListener('mouseup', () => world.isDragging = false);

    // --- 核心物理引擎 (Fix: 防震荡 + 能量计算) ---
    function calculatePhysics(dt) {
        const sinT = Math.sin(world.theta); 
        const cosT = Math.cos(world.theta); 

        // 1. 受力分析
        const F_gx = -world.m * g * sinT; // 重力沿斜面分量
        const F_N = world.m * g * cosT;   // 支持力
        const f_max = world.mu * F_N;     // 最大静摩擦力
        
        let F_f = 0; // 摩擦力 (代数值，沿斜面向上为正?) -> 不，沿x轴正向为正
        // 我们的x轴定义：沿传送带向右为正
        
        const v_rel = world.objV - world.vb; // 物块相对传送带速度

        // --- 摩擦力逻辑 ---
        // 判定共速 (Threshold)
        if (Math.abs(v_rel) < 0.001) {
            // 已共速/静止：摩擦力用于平衡重力
            const f_req = -F_gx;
            if (Math.abs(f_req) <= f_max) {
                F_f = f_req; // 静摩擦
            } else {
                F_f = Math.sign(f_req) * f_max; // 最大静/动摩擦
            }
        } else {
            // 滑动状态：摩擦力阻碍相对运动
            // v_rel > 0 (快) -> f 向后 (-1)
            // v_rel < 0 (慢) -> f 向前 (+1)
            F_f = -Math.sign(v_rel) * f_max;
        }
        
        // 2. 动力学方程
        const F_net = F_gx + F_f;
        world.accel = F_net / world.m;

        // 3. 能量计算 (累积)
        if (dt > 0) {
            // A. 摩擦生热 Q = f_slide * dS_rel
            // 注意：只有滑动摩擦才生热
            const isSliding = Math.abs(v_rel) > 0.001 && Math.abs(F_f) >= f_max * 0.99;
            if (isSliding) {
                const stepHeat = Math.abs(F_f) * Math.abs(v_rel) * dt;
                world.heat += stepHeat;
            }

            // B. 重力做功 W_G = Gx * dx
            // Gx 是重力沿x轴分量。 dx = v * dt
            // 如果 Gx 是负的（重力向下），且向上运动（v>0），Wg应为负。
            // F_gx 包含了方向符号，所以直接乘
            world.workG += F_gx * (world.objV * dt);

            // C. 电机做功 W_elec
            // 电机施加在传送带上的力 F_motor = - (摩擦力反作用力) = - (-F_f) = F_f
            // 严谨推导：
            // 物块受摩擦力 F_f (方向可能正可能负)
            // 传送带受摩擦力 -F_f
            // 电机为了维持传送带匀速，需施加力 F_m = -(-F_f) = F_f
            // 功率 P = F_m * vb = F_f * vb
            // 注意：这里的 F_f 是代数值（含正负号）
            // 验证：如果 F_f > 0 (向前推物块)，传送带被向后推，电机需要向前拉，P > 0，耗电。
            // 如果 F_f < 0 (向后阻碍物块)，传送带被向前推（发电工况），电机向后拉，P < 0，发电。
            world.workElec += F_f * world.vb * dt;
        }
    }

    function step() {
        if (!world.running) return;
        const dt = 0.016; // 16ms
        
        // 1. 计算当前的力和加速度
        calculatePhysics(dt);

        // 2. 预测下一帧速度 (半隐式欧拉)
        let nextV = world.objV + world.accel * dt;

        // 3. --- 核心修复：过零检测 (Anti-Oscillation) ---
        // 如果当前是滑动状态，且下一帧速度会穿过传送带速度 vb
        if (Math.abs(world.objV - world.vb) > 0.001) {
            // 符号异号，说明穿过了
            if ((world.objV - world.vb) * (nextV - world.vb) < 0) {
                // 强制锁死在共速状态
                nextV = world.vb;
                world.objV = world.vb; // 立即更新
                
                // 修正本帧的加速度，使其正好减速到 vb (为了能量计算精确性，虽然这里主要影响下一帧)
                // 但为了防止下一帧 calculatePhysics 计算出反向滑动摩擦，
                // 我们不需要做额外操作，因为下一帧 calculatePhysics 里的 if(v_rel < 0.001) 会接管
            }
        }
        
        world.objV = nextV;
        
        // 4. 更新位置
        const dx = world.objV * dt;
        world.objX += dx * PIXELS_PER_METER;
        world.beltOffset += world.vb * dt * PIXELS_PER_METER;
        world.timer += dt;

        // 5. 记录历史
        if(world.frameCounter % 5 === 0) { // 节流记录
            world.history.push({t: world.timer, v: world.objV, vb: world.vb});
            if(world.history.length > 200) world.history.shift(); // 限制长度
        }

        // 边界停止
        if(world.objX > BELT_LENGTH_PX + 100 || world.objX < -100) world.running = false;
    }

    function drawVTChart() {
        vCtx.clearRect(0,0,700,220);
        const offsetX = 50;
        const offsetY = 110; 
        const scaleV = 8; 
        const scaleT = 50; 

        // 轴
        vCtx.strokeStyle = "#ccc"; vCtx.lineWidth = 1;
        vCtx.beginPath(); vCtx.moveTo(offsetX, offsetY); vCtx.lineTo(680, offsetY); vCtx.stroke();
        vCtx.beginPath(); vCtx.moveTo(offsetX, 10); vCtx.lineTo(offsetX, 210); vCtx.stroke();
        
        vCtx.fillStyle = "#666"; vCtx.font = "12px Arial";
        vCtx.fillText("v (m/s)", offsetX - 40, 20);
        vCtx.fillText("t (s)", 670, offsetY + 15);

        if(world.history.length > 0) {
            // 传送带基准线
            vCtx.setLineDash([5,5]); vCtx.strokeStyle = "#3498db";
            let vy_b = offsetY - world.vb * scaleV;
            vCtx.beginPath(); vCtx.moveTo(offsetX, vy_b); vCtx.lineTo(680, vy_b); vCtx.stroke();
            vCtx.setLineDash([]);

            // 物块速度曲线
            vCtx.strokeStyle = "#e67e22"; vCtx.lineWidth = 2;
            vCtx.beginPath();
            const startT = world.history[0].t;
            world.history.forEach((h, i) => {
                let x = offsetX + (h.t - startT) * scaleT;
                let y = offsetY - h.v * scaleV;
                if(i===0) vCtx.moveTo(x, y); else vCtx.lineTo(x, y);
            });
            vCtx.stroke();
        }
    }

    function render() {
        // 1. 绘制场景
        sCtx.clearRect(0,0,700,350);
        sCtx.save();
        sCtx.translate(ORIGIN_X, ORIGIN_Y);
        sCtx.rotate(-world.theta); 

        // 传送带本体
        sCtx.fillStyle = "#34495e";
        sCtx.fillRect(0, 0, BELT_LENGTH_PX, 12);
        
        // 轮子
        sCtx.beginPath(); sCtx.arc(0, 6, 6, 0, Math.PI*2); sCtx.arc(BELT_LENGTH_PX, 6, 6, 0, Math.PI*2); sCtx.fill();

        // 运动纹理
        sCtx.strokeStyle = "rgba(255,255,255,0.5)"; sCtx.lineWidth = 2;
        for(let i=-200; i<BELT_LENGTH_PX + 200; i+=40) {
            let tx = (i + world.beltOffset) % BELT_LENGTH_PX;
            if(tx < 0) tx += BELT_LENGTH_PX;
            if(tx <= BELT_LENGTH_PX) {
                sCtx.beginPath(); sCtx.moveTo(tx, 0); sCtx.lineTo(tx, 12); sCtx.stroke();
            }
        }

        // 物块
        const boxX = world.objX - 50; 
        const boxY = -30;
        sCtx.fillStyle = world.isDragging ? "#d35400" : "#e67e22";
        sCtx.fillRect(boxX, boxY, 40, 30);
        sCtx.strokeStyle = "#fff"; sCtx.strokeRect(boxX, boxY, 40, 30);
        
        // 质心
        sCtx.fillStyle = "rgba(192, 57, 43,1.0)";
        sCtx.beginPath(); sCtx.arc(boxX + 20, boxY + 15, 3, 0, Math.PI*2); sCtx.fill();
        sCtx.restore();

        // 地面辅助线
        sCtx.strokeStyle = "#ccc"; sCtx.setLineDash([2, 4]);
        sCtx.beginPath(); sCtx.moveTo(0, ORIGIN_Y + 20); sCtx.lineTo(700, ORIGIN_Y + 20); sCtx.stroke();
        sCtx.setLineDash([]);

        // 2. 绘制图表 (节流)
        if(world.frameCounter % 5 === 0) drawVTChart();

        // 3. 更新数据面板
        updateStats();
    }

    function updateStats() {
        document.getElementById('stat-v').innerText = world.objV.toFixed(2);
        document.getElementById('stat-ds').innerText = world.relS.toFixed(2);
        document.getElementById('stat-q').innerText = world.heat.toFixed(2);
        document.getElementById('stat-wg').innerText = world.workG.toFixed(2);
        document.getElementById('stat-we').innerText = world.workElec.toFixed(2);
        
        // 动能变化
        const currentEk = 0.5 * world.m * world.objV * world.objV;
        const deltaEk = currentEk - world.startEk;
        document.getElementById('stat-dek').innerText = deltaEk.toFixed(2);
    }

    function animate() {
        if(world.running) {
            step();
            world.frameCounter++;
        }
        render(); 
        if(world.running) requestAnimationFrame(animate);
    }

    window.onload = () => { applyParams(); render(); };
</script>
</body>
</html>