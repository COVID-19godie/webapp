<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>传送带模型：受力分析可视化版</title>
    <link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/KaTeX/0.16.9/katex.min.css">
    <script src="https://cdn.bootcdn.net/ajax/libs/KaTeX/0.16.9/katex.min.js"></script>
    <script src="https://cdn.bootcdn.net/ajax/libs/KaTeX/0.16.9/contrib/auto-render.min.js"></script>

    <style>
        :root { --primary: #2c3e50; --accent: #e67e22; --bg: #f8f9fa; }
        body { font-family: 'Segoe UI', Arial, sans-serif; background: var(--bg); margin: 0; padding: 20px; display: flex; flex-direction: column; align-items: center; }
        .main-layout { display: flex; gap: 20px; max-width: 1100px; width: 100%; flex-wrap: wrap; }
        .canvas-area { flex: 2; display: flex; flex-direction: column; gap: 10px; min-width: 300px; }
        
        /* 画布样式优化：防止触摸滚动 */
        canvas { background: #fff; border-radius: 6px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); width: 100%; cursor: grab; touch-action: none; }
        canvas:active { cursor: grabbing; }
        
        .controls { flex: 1; background: white; padding: 20px; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); min-width: 300px; }
        .control-group { margin-bottom: 12px; display: flex; align-items: center; justify-content: space-between; }
        
        input[type="number"], select { width: 90px; padding: 6px; border: 1px solid #ccc; border-radius: 4px; text-align: center; font-weight: bold; }
        /* 输入框聚焦高亮 */
        input:focus { border-color: var(--accent); background: #fffdf5; outline: none; }
        
        .btn-stack { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 15px; }
        button { padding: 10px; border: none; border-radius: 4px; cursor: pointer; font-weight: bold; transition: background 0.2s; }
        .btn-apply { background: var(--primary); color: white; grid-column: span 2; margin-bottom: 5px; }
        .btn-play { background: #27ae60; color: white; font-size: 1.1em;}
        .btn-reset { background: #e74c3c; color: white; }
        
        .stats-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 15px; }
        .stat-card { background: #edf2f7; padding: 10px; border-radius: 4px; text-align: center; border-left: 4px solid var(--primary); }
        .stat-card small { display: block; font-size: 0.85em; color: #666; margin-bottom: 4px; }
        .stat-card span { font-family: 'Consolas', monospace; font-weight: bold; font-size: 1.2em; color: var(--primary); }
        
        /* 勾选框样式 */
        .checkbox-row { margin: 15px 0; padding: 10px; background: #f1f3f5; border-radius: 4px; display: flex; align-items: center; gap: 10px; font-weight: bold; color: #333; }
        input[type="checkbox"] { transform: scale(1.3); accent-color: var(--accent); }

        .formula-display { margin-top: 20px; padding: 15px; background: #fffaf0; border: 1px dashed var(--accent); border-radius: 4px; font-size: 0.9em; }
    </style>
</head>
<body>

<h2 id="page-title">传送带模型：动力学仿真 (含受力分析)</h2>

<div class="main-layout">
    <div class="canvas-area">
        <div class="stats-grid">
            <div class="stat-card"><small>物块速度 $v$ (m/s)</small><span id="stat-v">0.00</span></div>
            <div class="stat-card"><small>相对位移 $\Delta s$ (m)</small><span id="stat-ds">0.00</span></div>
            <div class="stat-card"><small>摩擦生热 $Q$ (J)</small><span id="stat-q">0.00</span></div>
            <div class="stat-card"><small>加速度 $a$ (m/s²)</small><span id="stat-a">0.00</span></div>
        </div>
        <canvas id="simCanvas" width="700" height="350"></canvas>
        <canvas id="vtCanvas" width="700" height="220"></canvas>
    </div>

    <div class="controls">
        <h4 style="margin-top:0">参数设置</h4>
        <div class="control-group">
            <label>传送带速度 $v_b$</label>
            <input type="number" id="in-vb" value="4.0" step="0.1" onchange="applyParams()">
        </div>
        <div class="control-group">
            <label>物块初速 $v_0$</label>
            <input type="number" id="in-v0" value="0.0" step="0.1" onchange="applyParams()">
        </div>
        <div class="control-group">
            <label>倾斜方向</label>
            <select id="in-tiltDir" onchange="applyParams()">
                <option value="1">向右上方 (/)</option>
                <option value="-1">向右下方 (\)</option>
            </select>
        </div>
        <div class="control-group">
            <label>倾角 $\theta$ (°)</label>
            <input type="number" id="in-theta" value="30" step="1" min="0" max="80" onchange="applyParams()">
        </div>
        <div class="control-group">
            <label style="color:var(--accent)">摩擦系数 $\mu$</label>
            <input type="number" id="in-mu" value="0.50" step="0.05" min="0" onchange="applyParams()">
        </div>
        <div class="control-group">
            <label>质量 $m$ (kg)</label>
            <input type="number" id="in-m" value="1.0" step="0.1" min="0.1" onchange="applyParams()">
        </div>

        <div class="checkbox-row">
            <input type="checkbox" id="chk-force" checked>
            <label for="chk-force">显示受力分析 (FBD)</label>
        </div>

        <button class="btn-apply" onclick="applyParams()">刷新参数 (重置)</button>
        <div class="btn-stack">
            <button id="playBtn" class="btn-play" onclick="togglePlay()">开始 / 暂停</button>
            <button class="btn-reset" onclick="hardReset()">全复位</button>
        </div>

        <div class="formula-display" id="formula-box">
            动力学方程:<br>
            $$ F_{合} = F_{G_x} + f = ma $$
            $$ f = \begin{cases} -\mu mg\cos\theta \cdot \text{sgn}(v_{rel}) & \text{滑动} \\ -F_{G_x} & \text{相对静止} \end{cases} $$
        </div>
    </div>
</div>

<script>
    const simCanvas = document.getElementById('simCanvas');
    const sCtx = simCanvas.getContext('2d');
    const vtCanvas = document.getElementById('vtCanvas');
    const vCtx = vtCanvas.getContext('2d');
    const g = 9.8;

    const ORIGIN_X = 60;  
    const ORIGIN_Y = 260; 
    const PIXELS_PER_METER = 40; 
    const BELT_LENGTH_PX = 580;

    let world = {
        running: false,
        vb: 4, v0: 0, mu: 0.5, theta: 0, m: 1, tiltDir: 1,
        initialX: 100,
        objX: 100,     
        objV: 0, relS: 0, heat: 0, accel: 0,
        beltOffset: 0, history: [], isDragging: false, timer: 0,
        // 存储受力用于绘图
        forces: { gx: 0, n: 0, f: 0 }
    };

    function refreshMath() {
        if (typeof renderMathInElement === 'function') {
            renderMathInElement(document.getElementById('formula-box'), {
                delimiters: [ {left: '$$', right: '$$', display: true}, {left: '$', right: '$', display: false} ],
                throwOnError: false
            });
        }
    }

    function applyParams() {
        world.vb = parseFloat(document.getElementById('in-vb').value) || 0;
        world.v0 = parseFloat(document.getElementById('in-v0').value) || 0;
        world.mu = parseFloat(document.getElementById('in-mu').value) || 0;
        let angle = parseFloat(document.getElementById('in-theta').value) || 0;
        world.tiltDir = parseInt(document.getElementById('in-tiltDir').value);
        world.m = parseFloat(document.getElementById('in-m').value) || 1;
        
        world.theta = angle * (Math.PI / 180) * world.tiltDir;
        world.objX = world.initialX;
        
        resetSimData();
        refreshMath();
    }

    function resetSimData() {
        world.objV = world.v0;
        world.relS = 0; world.heat = 0; world.accel = 0; world.timer = 0;
        world.history = []; world.running = false;
        document.getElementById('playBtn').innerText = "开始仿真";
        calculatePhysics(0); // 预计算受力
        updateStats();
        drawVTChart(); // 清空图表
        render(); // 立即重绘
    }

    function hardReset() {
        world.initialX = 100; world.objX = 100;
        applyParams();
    }

    function togglePlay() {
        if(!world.running && world.history.length === 0) {
             world.initialX = world.objX;
        }
        world.running = !world.running;
        document.getElementById('playBtn').innerText = world.running ? "暂停" : "继续";
        if(world.running) animate();
    }

    function getBeltPos(e) {
        const rect = simCanvas.getBoundingClientRect();
        const dx = (e.clientX - rect.left) - ORIGIN_X;
        const dy = (e.clientY - rect.top) - ORIGIN_Y;
        const beltX = dx * Math.cos(-world.theta) + dy * Math.sin(-world.theta);
        const beltY = -dx * Math.sin(-world.theta) + dy * Math.cos(-world.theta);
        return { x: beltX, y: beltY };
    }

    simCanvas.addEventListener('mousedown', e => {
        const pos = getBeltPos(e);
        if (Math.abs(pos.x - (world.objX - 30)) < 60 && Math.abs(pos.y + 15) < 50) {
            world.isDragging = true;
            world.running = false;
            document.getElementById('playBtn').innerText = "开始仿真";
        }
    });

    window.addEventListener('mousemove', e => {
        if (world.isDragging) {
            const pos = getBeltPos(e);
            world.objX = Math.max(50, Math.min(BELT_LENGTH_PX + 50, pos.x + 30)); 
            world.initialX = world.objX;
            resetSimData();
        }
    });

    window.addEventListener('mouseup', () => world.isDragging = false);

    // --- 物理计算核心 ---
    function calculatePhysics(dt) {
        const sinT = Math.sin(world.theta); 
        const cosT = Math.cos(world.theta); 

        // 1. 重力分量 (Gx)
        // 沿传送带向右为正x。
        // 向右上倾斜(theta>0): 重力沿斜面向下(负x) -> Gx = -mg*sin(theta)
        // 向右下倾斜(theta<0): 重力沿斜面向下(正x) -> Gx = -mg*sin(theta) (sin负值变正)
        const F_gx = -world.m * g * sinT;

        // 2. 支持力 (N)
        const F_N = world.m * g * cosT;
        const f_max = world.mu * F_N; 

        let F_f = 0;
        const v_rel = world.objV - world.vb; // 相对速度

        // 3. 摩擦力 (f)
        // 判定共速
        if (Math.abs(v_rel) < 0.002) { 
            // 相对静止：静摩擦力平衡重力下滑分量
            // F_net = F_gx + f = 0 => f = -F_gx
            const f_req = -F_gx;
            if (Math.abs(f_req) <= f_max + 0.001) {
                F_f = f_req; // 静摩擦
            } else {
                F_f = Math.sign(f_req) * f_max; // 滑动/最大静摩擦
            }
        } else {
            // 滑动：摩擦力阻碍相对运动
            // v_rel > 0 (快) -> f 向后(-)
            // v_rel < 0 (慢) -> f 向前(+)
            F_f = -Math.sign(v_rel) * f_max;
            
            if (dt > 0) {
                world.heat += Math.abs(F_f) * Math.abs(v_rel) * dt;
                world.relS += Math.abs(v_rel) * dt;
            }
        }

        // 保存受力数据 (供绘图)
        world.forces.gx = F_gx;
        world.forces.n = F_N;
        world.forces.f = F_f;

        // 4. 合力与加速度
        const F_net = F_gx + F_f;
        world.accel = F_net / world.m;
    }

    function step() {
        if (!world.running) return;
        const dt = 0.016;
        
        calculatePhysics(dt);

        // 简单的防震荡逻辑：如果即将穿过vb，则锁死
        let nextV = world.objV + world.accel * dt;
        if (Math.abs(world.objV - world.vb) > 0.001) {
             if ((world.objV - world.vb) * (nextV - world.vb) < 0) {
                 nextV = world.vb; // 锁死共速
             }
        }
        world.objV = nextV;
        
        world.objX += world.objV * dt * PIXELS_PER_METER;
        world.beltOffset += world.vb * dt * PIXELS_PER_METER;
        world.timer += dt;

        // 历史记录 (加简单的降采样)
        if (Math.floor(world.timer * 100) % 5 === 0) {
            world.history.push({t: world.timer, v: world.objV, vb: world.vb});
            if(world.history.length > 300) world.history.shift();
        }
        
        if(world.objX > BELT_LENGTH_PX + 150 || world.objX < -150) world.running = false;
    }

    // --- 绘图助手 ---
    function drawArrow(ctx, x, y, len, color, label) {
        if (Math.abs(len) < 5) return; // 太短不画
        
        ctx.save();
        ctx.strokeStyle = color; ctx.fillStyle = color; ctx.lineWidth = 3;
        
        // 箭杆
        const endX = x + len;
        ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(endX, y); ctx.stroke();
        
        // 箭头 (始终在末端)
        const head = 8;
        const dir = Math.sign(len);
        ctx.beginPath();
        ctx.moveTo(endX + dir*2, y); // 稍微突出一点
        ctx.lineTo(endX - dir*head, y - head*0.6);
        ctx.lineTo(endX - dir*head, y + head*0.6);
        ctx.fill();
        
        // 文字标签
        ctx.font = "bold 13px Arial";
        const txtW = ctx.measureText(label).width;
        // 文字放在箭头上方或下方
        const txtX = x + len/2 - txtW/2;
        const txtY = y - 8;
        ctx.fillText(label, txtX, txtY);
        
        ctx.restore();
    }

    function render() {
        sCtx.clearRect(0,0,700,350);
        sCtx.save();
        
        sCtx.translate(ORIGIN_X, ORIGIN_Y);
        sCtx.rotate(-world.theta); 

        // 传送带
        sCtx.fillStyle = "#34495e";
        sCtx.fillRect(0, 0, BELT_LENGTH_PX, 12);
        
        // 轮子
        sCtx.beginPath(); sCtx.arc(0, 6, 6, 0, Math.PI*2); sCtx.arc(BELT_LENGTH_PX, 6, 6, 0, Math.PI*2);
        sCtx.fill();

        // 纹理
        sCtx.strokeStyle = "rgba(255,255,255,0.5)";
        sCtx.lineWidth = 2;
        for(let i=-200; i<BELT_LENGTH_PX + 200; i+=40) {
            let tx = (i + world.beltOffset) % BELT_LENGTH_PX;
            if(tx < 0) tx += BELT_LENGTH_PX;
            if(tx <= BELT_LENGTH_PX) {
                sCtx.beginPath(); sCtx.moveTo(tx, 0); sCtx.lineTo(tx, 12); sCtx.stroke();
            }
        }

        // 物块
        const boxX = world.objX - 50; 
        const boxY = -30;
        
        sCtx.fillStyle = world.isDragging ? "#d35400" : "#e67e22";
        sCtx.fillRect(boxX, boxY, 40, 30);
        sCtx.strokeStyle = "#fff";
        sCtx.strokeRect(boxX, boxY, 40, 30);
        
        // 质心点
        const cx = boxX + 20; 
        const cy = boxY + 15;
        sCtx.fillStyle = "rgba(192, 57, 43,1.0)";
        sCtx.beginPath(); sCtx.arc(cx, cy, 3, 0, Math.PI*2); sCtx.fill();

        // --- 核心功能：受力分析绘制 ---
        if (document.getElementById('chk-force').checked) {
            const scale = 8; // 力矢量的显示放大倍数
            
            // 1. Gx (重力沿斜面分量) - 红色
            drawArrow(sCtx, cx, cy, world.forces.gx * scale, "#e74c3c", "Gx");
            
            // 2. N (支持力，垂直斜面向上，即 -y 方向) - 蓝色
            // 这里的 cy 是正值，向上是 -y，所以 drawArrow 传入负长度表示向上? 
            // 不，drawArrow 是画水平箭头的 (在 rotate 坐标系下，y轴是垂直的)
            // 我们需要修改 drawArrow 或者手动画垂直箭头？
            // 简单的做法：复用 drawArrow 但在调用前旋转一下？或者直接画线。
            // 为了代码整洁，我们手动画 N 和 G 的垂直分量
            
            // 绘制 N (垂直向上，即 -y)
            sCtx.save();
            sCtx.translate(cx, cy);
            sCtx.rotate(-Math.PI/2); // 旋转90度，变成向上
            drawArrow(sCtx, 0, 0, world.forces.n * scale, "#3498db", "N");
            sCtx.restore();

            // 绘制 f (摩擦力，沿斜面 x 轴) - 绿色
            drawArrow(sCtx, cx, cy + 18, world.forces.f * scale, "#2ecc71", "f"); 
            // y+18 是为了错开 Gx，防止重叠
        }

        sCtx.restore();

        // 地面
        sCtx.strokeStyle = "#ccc";
        sCtx.setLineDash([2, 4]);
        sCtx.beginPath(); sCtx.moveTo(0, ORIGIN_Y + 20); sCtx.lineTo(700, ORIGIN_Y + 20); sCtx.stroke();
        sCtx.setLineDash([]);

        drawVTChart();
        updateStats();
    }

    function drawVTChart() {
        vCtx.clearRect(0,0,700,220);
        const offsetX = 50;
        const offsetY = 110; // y=0 在中间
        const scaleV = 8; 
        const scaleT = 50; 

        vCtx.strokeStyle = "#ccc"; vCtx.lineWidth = 1;
        vCtx.beginPath(); vCtx.moveTo(offsetX, offsetY); vCtx.lineTo(680, offsetY); vCtx.stroke();
        vCtx.beginPath(); vCtx.moveTo(offsetX, 10); vCtx.lineTo(offsetX, 210); vCtx.stroke();
        
        vCtx.fillStyle = "#666"; vCtx.font = "12px Arial";
        vCtx.fillText("v (m/s)", offsetX - 40, 20);
        vCtx.fillText("t (s)", 670, offsetY + 15);

        if(world.history.length > 0) {
            // 传送带
            vCtx.setLineDash([5,5]); vCtx.strokeStyle = "#3498db";
            let vy_b = offsetY - world.vb * scaleV;
            vCtx.beginPath(); vCtx.moveTo(offsetX, vy_b); vCtx.lineTo(680, vy_b); vCtx.stroke();
            vCtx.setLineDash([]);

            // 物块
            vCtx.strokeStyle = "#e67e22"; vCtx.lineWidth = 2;
            vCtx.beginPath();
            const startT = world.history[0].t;
            world.history.forEach((h, i) => {
                let x = offsetX + (h.t - startT) * scaleT;
                let y = offsetY - h.v * scaleV;
                if(i===0) vCtx.moveTo(x, y); else vCtx.lineTo(x, y);
            });
            vCtx.stroke();
        }
    }

    function updateStats() {
        document.getElementById('stat-v').innerText = world.objV.toFixed(2);
        document.getElementById('stat-ds').innerText = world.relS.toFixed(2);
        document.getElementById('stat-q').innerText = (world.heat).toFixed(2);
        
        let aStr = world.accel.toFixed(2);
        if (world.accel > 0) aStr = "+" + aStr;
        document.getElementById('stat-a').innerText = aStr;
    }

    function animate() {
        step(); render(); 
        if(world.running) requestAnimationFrame(animate);
    }

    window.onload = () => { applyParams(); animate(); };
</script>
</body>
</html>